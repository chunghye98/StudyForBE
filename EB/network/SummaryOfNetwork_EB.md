# Summary of Network

> 목차
> * What is OSI 7 Layer

## 1. What is OSI 7 Layer

* 계층을 구분하는 이유

통신 과정을 단계별로 파악할 수 있고, 특정한 곳에서 이상이 생기면 그 단계만 수정할 수 있기 때문이다.

### 물리 계층

* 리피터
* 케이블
* 허브

데이터를 전기 신호로 변환해서 주고 받는 기능을 하는 공간이다.

데이터를 전송하는 역할만 한다.

### 데이터 링크 계층

* 브릿지
* 스위치

물리 계층으로 송수신되는 정보를 관리하여 안전하게 전달되도록 도와주는 역할을 한다.

MAC 주소를 통해 통신한다.

프레임에 MAC 주소를 부여하고 오류 검출, 재전송, 흐름 제어 기능을 제공한다.

### 네트워크 계층

* 라우터
* IP

데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 제공한다.

라우터를 통해 이동할 경로를 선택하여 IP 주소를 지정하고, 해당 경로에 따라 패킷을 전달해준다.

라우팅, 흐름 제어, 오류 제어, 세그먼테이션 등을 수행한다.

### 전송 계층

* TCP
* UDP

TCP와 UDP 프로토콜을 통해 통신을 활성화한다.

포트를 열어두고 프로그램들이 전송할 수 있도록 한다.

### 세션 계층

* API
* Socket

데이터가 통신하기 위한 논리적인 연결을 담당한다.

### 표현 계층

* JPEG
* MPEG

데이터 표현에 대한 독립성을 제공하고 암호화 기능을 제공한다.

파일 인코딩, 명령어 압축, 암호화를 담당한다.

### 응용 계층

* HTTP
* FTP
* DNS

최종 목적지로 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.

사용자 인터페이스, 전자우편, 데이터베이스 관리 등의 서비스를 제공한다.

## 2. HTTP GET vs. POST

둘 다 Http 프로토콜을 이용해서 서버에 무엇인가 요청할 때 사용하는 http method이다. 

* GET

요청하는 데이터가 Http request message의 header 부분에 url이 담겨서 전송된다. 그렇기 때문에 url 상에 `?` 뒤에 데이터가 붙어 request를 보내게 된다. 이러한 방식은 url이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다. 또한, 보안이 필요한 데이터에 대해서는 데이터가 그대로 노출되므로 GET 방식은 적절하지 않다.

> 예: 비밀번호 와 같은 보안이 필요한 정보들


* POST

request는 http request message의 body 부분에 데이터가 ㄷ마겨서 전송된다. 그렇기 때문에 바이너리 데이터를 요청하는 경우, POST 방식으로 보내야 하는 것처럼 데이터 크기가 GET 보다 크고 보안 면에서 낫다. 

둘의 용도 차이를 알아보자.!

GET은 가져올 때 사용한다. 즉, 서버에서 어떤 데이터를 가져와서 보여주는 용도로 서버의 값이나 상태 등을 변경하지 않는다.

SELECT적인 성향을 갖고 있다고 볼 수 있다. 

반면에 POST는 서버의 값이나 상태를 변경하기 위해서 또는 추가하기 위해서 사용된다.

좀 더 살펴보면, GET은 브라우저에서 캐싱할 수 있다. 때문에 POST 방식으로 요청해야 할 것을 보내는 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청한다면 기존에 캐싱된 데이터가 응답될 가능성이 존재한다. 

## 3. TCP/IP 프로토콜을 스택 4 계층으로 설명하시오.

* Link 계층

물리적인 영역의 표준화에 대한 결과이다.

가장 기본이 되는 영역으로, LAN, WAN과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역이다.

* IP 계층

경로 검색을 해주는 계층이다.

IP 자체는 비연결지향적이며 신뢰할 수 없는 프로토콜이다.

데이터를 전송할 때마다 거쳐야 할 경로를 선택해주지만, 경로가 일정하지 않다.

데이터 전송 중에 경로 상 문제가 발생할 때, 데이터가 손실되거나 오류가 발생하는 문제가 발생할 수 있다.

IP 계층은 오류 발생에 대한 대비가 되어 있지 않은 프로토콜이다.

* TCP/UDP 계층

데이터의 실제 송수신을 담당한다.

UDP는 TCP에 비해 상대적으로 간단하고, TCP는 신뢰성 있는 데이터 전송을 담당한다.

TCP는 데이터 전송시, IP 프로토콜을 기반으로 한다.
> 데이터의 순서에 따라 올바르게 전송되었는지 확인하며 대화를 주고 받는 방식이다.

* 어플리케이션 게층

서버와 클라이언트를 만드는 과정에서 프로그램 성격에 따라 데이터 송수신에 대한 약속들이 정해진다.

## 4. TCP vs. UDP 

* TCP

대부분 인터넷 응용 분야들은 신뢰성과 순차적인 전달을 필요로 한다. UDP로는 이를 만족할 수 없어 등장한 것이 TCP이다. TCP는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송하도록 특별히 설계되었다. TCP 서비스는 송신자와 수신자 모두 소켓이라 부르는 종단점을 생성함으로써 이루어진다. TCP에서 연결 설정은 3 way handshake를 통해 이루어진다.
> 소켓은 연결만을 담당한다.

> 스트림 전송으로 전송 데이터의 크기가 무제한이다.

> 패킷이란 인터넷 내에서 데이터를 보내기 윟나 경로 배정을 효율적으로 하기 위해서 데이터를 여러 개의 조각들로 나누어 저송을 하는 데, 이때 조각을 말한다.

연결형 서비스로 가상 회선 방식을 제공한다.
> 발신지와 수신지를 연결하여 패킷을 전송하기 위한 논리적 경로를 배정한다는 말이다. 

모든 TCP 연결은 전이중 , 점대점 방식이다. 
> 전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미한다.

> 점대점이란 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미한다.

TCP는 멀티캐스팅이나 브로드 캐스팅을 지원하지 않는다.

* UDP

UDP는 비연결 프로토콜이다. IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다. UDP는 흐름제어, 오류 제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. 이 모두가 사용자 프로세스의 몫이다. UDP가 행하는 것은 프로토콜을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다.

종종 클라이언트는 서버로 짧은 요청을 보내고 짧은 응답을 기대한다. 만약 요청 또는 응답이 손실된다면 클라이언트는 시간초과되고 다시 시도할 수 있으면 된다. 코드가 간단할 뿐만 아니라 TCP 처럼 초기 설정에서 요구되는 프로토콜보다 적은 메세지가 요구된다.

UDP를 사용한 것들에는 DNS가 있다. 어떤 호스트 네임의 IP주소를 찾을 필요가 있는 프로그램은 DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다. 사전에 설정이 필요하지 않으며 그 후에 해제가 필요하지 않다.
> TCP의 경우, 연결 설정과 연결 해제 과정이 필요하다.

UDP의 특징을 정리하면, 비연결형 서비스로 데이터그램 방식을 제공한다. 
> 데이터그램은 독립적인 관계를 지니는 패킷이란 뜻으로, 각각의 패킷이 다른 경로로 전송되고 독립적으로 처리된다.

정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 ㅇ낳는다.

UDP 헤더의 체크섬 필드를 통해 최소한의 오류만을 검출한다.

TCP보다 속도가 빠르다.

그래서 주로 실시간 서비스에서 자주 사용된다.

TCP는 소켓 기반이지만 UDP는 IP를 기반으로 데이털르 전송한다.

[망나니개발자님 블로그](https://mangkyu.tistory.com/15)

## 4. Http vs. Https

### HTTP의 문제점

1. HTTP는 평문 통신이기 때문에 도청이 가능하다.
2. 통신 상대를 확인하지 않기 때문에 위장이 가능하다.
3. 완전성을 증명할 수 없기 때문에 변조가 가능하다.

### TCP/IP는 도청 가능한 네트워크이다.

TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 패킷을 수집하는 것만으로 도청할 수 있다. 평문으로 통신할 경우 메세지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 한다.

* 보완 방법
1. 통신 자체를 암호화 SSL 혹은 TSL 이라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할 수 있다. 
2. 콘텐츠를 암호화한다.

말 그대로 HTTP를 사용해서 운반하는 내용인, http message에 포함되는 콘텐츠만 암호화하는 것이다. 암호화해서 전송하면 받는 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다.

### 통신 상대를 확인하지 않기 때문에 위장이 가능하다.

HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리가 없기 때문에 누구든지 요청을 보낼 수 있다.

IP 주소나 포트 등에서 그 웹서버에 액세스 제하니 없는 경우, 요청이 오면 상대가 누구든지 무언가의 응답을 반환한다. 

이러한 특징은 아래와 같은 문제점을 유발한다.

1. 요청을 보낸 곳의 웹 서버가 원래 의도한 응답을 보내야 하는 웹서버인지 확인할 수 없다.

2. 응답을 반환한 곳의 클라이언트가 원래 의도한 요청을 보낸 클라이언트인지를 확인할 수 없다.

3. 통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다.

4. 어디에서 누가 요청했는지 확인할 수 없다.

5. 의미없는 요청도 수신한다. --> Dos 공격을 방지 할 수 없다.

* 보완 방법

SSL을 통해 보완할 수 있다. SSL은 상대를 확인하는 수단으로 증명서를 제공하고 있다. 증명서는 신뢰할 수 있는 제 3자 기관에 의해 발행되는 것이 때문에 서버나 클라이언트가 실재하는 사실을 증명한다. 이 증명서를 이용함으로써 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 된다. 

### 완전성을 증명할 수 없기 때문에 변조가 가능하다.

여기서 완전성이란 정보의 정확성을 의미한다. 서버 또는 클라이언트에서 수신한 내용이 송신 측에서 보낸 내용과 일치한다는 것을 보장할 수 없는 것이다. 요청이나 응답이 발신된 후에 상대가 수신하는 사이에 누군가에 의해 변조되더라도 이 사시을 알 수 없다. 이와 같이 공격자가 도중에 요청이나 응답을 빼앗아 변조하는 공격을 중간자 공격이라 부른다.

* 보완 방법

해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하짐나 확실히 확인할 수 있는 것은 아니다. 확실히 방지하기 위해서는 HTTPS를 사용해야 한다. 

### HTTPS

HTTPS는 SSL을 포함한 HTTP라고 할 수 있다. HTTP 통신하는 소켓 부분을 SSL 혹은 TSL이라는 프토콜로 대체하는 것 뿐이다. HTTP는 원래 TCP와 직접 통신했지만 HTTPS에서 HTTP는 SSL과 통신하고 SSL이 TCP와 통신하게 된다. SSL을 사용한 HTTPS는 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.

HTTPS의 SSL에서는 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용한다. 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식이다.

* 모든 웹 페이지에서 HTTPS를 사용하지 않는 이유

평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구한다. 통신할 때마다 암호화를 하면 추가적인 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 요청의 수가 상대적으로 줄어들게 된다.

하지만 최근에는 하드웨어의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일나지 않으며, 새로운 표준인 HTTP 2.0을 함께 이용한다면 오히려 HTTPS가 HTTP보다 더 빠르게 동작한다. 따라서 현재 모든 웹페이지에서 HTTPS를 적용하는 방향으로 바뀌어 가고 있다.

[깃헙 cs 레포](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network)