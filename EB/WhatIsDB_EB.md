# What is Database

> 목차
> * What is Data modeling
> * What is Relational Database
> * What is NoSQL
> * What is difference between RDB and NoSQL

## 1. What is Data modeling
정보 시스템을 구축하기 위한 데이터 관점의 업무 분석 기법이다. 데이터 모델링은 데이터베이스를 구축하기 위한 분석/설계의 과정이다. 
> 데이터베이스는 데이터 저장소이다.

**데이터 모델링의 유의점**

* 중복

데이터 모델은 같은 데이터를 사용하는 사람, 시간, 그리고 장소를 파악하는데 도움을 줌으로써 데이터베이스가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록 한다. <br/>
즉, 동일한 데이터가 여러 장소에 저장되어 발생할 수 있는 side-effect를 방지해야 한다.

* 비유연성

데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무 변화에도 데이터 모델이 수시로 변경됨으로써 유지보수의 어려움을 가중시킬 수 있다. 

* 비일관성

데이터의 중복이 없더라도 비일관성은 발생할 수 있다. 

**데이터 모델링 3단계**

1. Conceptual Modeling

엔티티와 속성을 도출하고 ERD를 작성한다.

2. Logical Modeling

식별자를 도출하고 속성과 관계 등을 정의한다. 

정규화를 수행하여 데이터 모델의 독립성과 재사용성을 확보한다.

3. Physical Modeling

실제 Database를 구축한다.

**데이터 모델링 3요소**

1. 엔티티
2. 관계
3. 속성

**ERD**

ERD는 Entity-relationship diagram으로 DB를 시각적으로 표현하는 데 사용한다.

엔티티는 사각형, 관계는 마름모, 속성은 타원형으로 표현한다.

**엔티티**

업무에서 관리해야 하는 데이터의 집합이다.

유일한 식별자에 의해 식별이 가능해야 한다.

영속적으로 존재하는 인스턴스의 집합이어야 한다.
> 인스턴스란??

엔티티는 반드시 속성이 있어야 한다.

엔티티는 다른 엔티티와 최소 한 개 이상의 관계가 있어야 한다.

**속성**

엔티티가 가지는 최소 의미 단위로, 인스턴스의 구성요소이다.

속성 표기법에는 IE 표기법과 Barker 표기법이 있다.

업무에서 필요하고 관리하고자 하는 정보이자, 유일한 식별자에 함수적으로 종속된다. 

속성값은 하나만 가진다.

**관계**

엔티티 간의 논리적인 관련성을 의미한다.

관계를 표기할 때에는 관계차수 Cardinality와 관계선택사양 Optionality를 표기한다.

**식별자**

1. primary key

엔티티를 대표하는 키

2. candiate key

유일성과 최소성을 만족하는 키

3. super key

유일성만 만족하는 키

4. alternative key

기본키를 제외한 나머지 후보키

5. foreign key

여러 테이블의 PK 필드

참조 무결성을 확인하기 위해 사용된다.

**정규화**

쉽게 말해, 데이터를 분해하는 과정이다. 이상현상 anomaly를 제거한다.

* 1NF

속성의 원자성을 확보한다.

PK를 설정한다.

중복속성에 대한 분리를 한다. repeating group 분리하기

* 2NF

PK가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거한다. 
> partial functional depedency는 결정자와 종속자의 관계로, 결정자의 값으로 종속자의 값을 알 수 있다. 

* 3NF

PK를 제외한 컬럼 간의 종속성을 제거한다. 즉, 이행 함수 종속성을 제거한다.

**정규화 특징**

정규화로 인한 insert, alter, delete 성능 향상

데이터 중복 최소화

재활용성 증가

select 시 조건에 따라 성능 저하 발생할 수도 있음 -> 반정규화로 해결 가능


**반정규화**

데이터 중복을 허용하여 조인을 줄이는 DB 성능 향상 방법으로, 데이터의 무결성을 희생하고 조회 성능을 향상한다.

**테이블 반정규화*

* 테이블 병합

1. 1:1 관계 테이블 병합
2. 1:M 관계 테이블 병합
3. 슈퍼-서브 타입 테이블 병합

* 테이블 분할

1. 수직 분할

컬럼 단위로 테이블을 분리

2. 수평 분할

로우 단위로 집중 발생되는 트랜잭션을 분석하여 분리

* 테이블 추가

1. 중복 테이블 추가

업무나 서버가 다를 경우 중복 테이블 생성하여, 원격 조인 제거

2. 통계 테이블 추가

aggregation function을 미리 수행하여 계산해둔다.

3. 이력 테이블 추가

대량의 이력 데이터를 처리할 때, 불특정 날 조회나 최근 값을 조회 시 발생할 수 있는 성능저하 예방

4. 부분 테이블 추가

자주 이용하는 컬럼으로 구성된 테이블 생성

**칼럼 반정규화*

* 중복 컬럼 추가

* 파생 컬럼 추가

필요한 값을 미리 계산한 컬럼 추가

* 이력 테이블 컬럼 추가

* PK에 의한 컬럼 추가

PK의 종속자를 일반속성으로 생성

* 응용 시스템의 오작동을 위한 컬럼 추가

사용자가 데이터처리를 하다가 잘못 처리하여 원래 값으로 복구하기를 원하는 경우, 이전 데이터를 임시적으로 중복하여 보관하는 기법이다.

**관계 반정규화*

* 중복 관계 추가

데이터 무결성 보장 가능

**대용량 데이터 처리**

지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우, View를 사용하면 이를 해결할 수도 있다.

대량의 데이터 처리나 부분 처리에 의해 성능이 저하되는 경우에 클러스터링을 적용하거나 인덱스를 조정함으로써 성능을 향상시킬 수 있다.

대량의 데이터는 PK의 성격에 따라 부분적인 테이블로 분리할 수 잇다.

응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다.

**Row Chaining**

row 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상 저장하는 방식

**Row Migration**

데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 빈공간을 찾아 저장하는 방식

**Partioning**

하나의 테이블에 많은 양의 데이터가 저장되면 인덱스를 추가하고 테이블을 몇 개로 쪼개도 성능이 저하되는 경우가 있다. 이때 논리적으로는 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리하여 데이터 액세스 성능도 향상시키고, 데이터 관리 방법도 개선할 수 있도록 테이블에 적용하는 기법이다.

분산 저장으로 데이터 조회 범위를 줄여 성능을 향상시킨다.


## 2. What is RDB

Relation에 데이터를 저장하고, 집합 연산과 관계 연산이 가능한 DB이다.

고정된 행과 열로 구성된 테이블에 데이터를 저장한다.

정규화를 통해 이상현상 및 중복 데이터 를 제거하고, 동시성 관리와 병행 제어를 통해 데이터 동시 조작이 가능하다.

관계형 데이터베이스의 대표적인 DBMS는 MySQL, Oracle, SQLite, MariaDB, PostgressSQL이 있다.

SQL을 사용하기 때문에 스키마가 뚜렷하게 보인다. 즉, 테이블 간의 관계를 직관적으로 파악할 수 있다.

**집합연산**

* Union
* Difference
* Intersection
* Catesian Product

**관계연산**

* selection

조건에 맞는 행 조회

* Projection

조건에 맞는 컬럼 조회

* Join

공통 속성을 사용하여 새로운 Relation 생성

* Division

공통요소를 추출하여 중복된 행 제거

**SQL**

Structured Query Language로 RDB에서 사용하는 언어이다. CRUD 기능 제공한다.

* DML 데이터 조작

```` bash

select * from TABLE where id = 1 ;

insert into TABLE ( column ) values ( 1 ) ;

update TABLE set column = 2 ;

delete from TABLE where id = 1 ;

````

* DDL 데이터 정의

```` bash

create table TABLE (
    column int not null,
    ...
    // 제약조건의 종류
    // 1. pk
    // 2. unique key
    // 3. not null
    // 4. check
    // 5. fk
);

alter table TABLE  alter (
    column int null,
    ...
);

drop table TABLE ; // rollback 불가능

rename TABLE to TABLE1 ;

````

* DCL 데이터 제시어

GRANT

REVOKE

* TCL 트랜잭션 제시어

COMMIT

ROLLBACK

> 트랜잭션? <br/>
> 논리적인 작업의 단위이다. <br/>
> 원자성, 일관성, 고립성, 영속성의 특징을 갖는다.

TCL은 데이터 무결성 보장을 목적으로 한다.

**Where절**

from 절 다음에 위치한다.

비교 연산자를 사용한다.

* 비교 연산자
* SQL 비교 연산자 ( Between, in, like, isnull )
* 논리 연산자 ( and, or, not )

where절은 grouup by절 보다 먼저 수행된다.

**Group by**

group by 절을 통해 소그룹별 기준을 정한 후, select 절에 집계 함수를 사용한다.

집계 함수의 통계 정보는 Null 값을 가진 행을 제외하고 수행한다.

having 절은 group by 절의 기준 항목이나 소그룹의 집계 함수를 이용한 조건을 표시할 수 있다.

**order by**

기본 정렬은 오름차순이다.

**Select 문장 실행 순서**

1. from
2. where
3. group by
4. having
5. select
6. order by

**join**

* inner join

동일한 값이 있는 행만 반환한다.

* natural join

오라클에서만 지원한다.

두 테이블 간의 동일한 이름을 갖는 모든 컬럼들에 대해 EQUI join을 수행한다.

using, on, where절에서 join을 수행할 수 없다.

* using 조건절

오라클에선만 지원한다.

from 절에서 using 조건절을 이용하면 같은 이름을 가진 컬럼 중 원하는 컬럼에 대해서만 선택적으로 EQUI join을 할 수 있다.

* on 조건절

컬럼명이 다르더라도 join 조건을 사용할 수 있다.

* cross join

테이블 간 join 조거닝 없는 경우, 생길 수 있는 모든 데이터의 조합

* outer join

left/ right / full 로 구분된다.

위의 3가지가 기준이 되어 수행된다.

**서브쿼리**

단일 행 또는 복수 행을 비교 연산자와 함께 사용할 수 있다.

select, from, having, order by 절에서 사용이 가능하다.

서브쿼리의 결과가 복수 행 결과를 반환하는 경우에는 in, any, all 등 복수행 비교연산자와 사용하여야 한다.

from 절에서 사용되는 서브쿼리를 **인라인 뷰*라고 한다. 이는 sql문이 실행될 때만 임시적으로 생성되는 동적인 뷰이기 때문에 DB에 해당 정보가 저장되지 않는다.


**뷰**

* 독립성

테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 된다.

* 편리성

복잡한 쿼리를 뷰로 생성함으로써, 관련 쿼리를 단순하게 작성할 수 있다.

* 보안성

숨기고 싶은 정보가 존재한다면, 제외할 수 있다.

## 3. What is NoSQL

관계형 데이터베이스를 제외한 나머지 유형을 총칭한다.

Not only SQL로, 데이터가 고정되어 있지 않은 데이터베이스를 가리킨다.

NoSQL 데이터베이스는 데이터 모델에 따라 유형이 다양하다. 
> document, key-value, wide colum, graph 가 있다.

NoSQL에도 스키마가 존재하며, 대량의 데이터와 높은 사용자 부하에도 손쉽게 확장이 가능하다.
> RDB는 스키마에 맞게 입력해야 하는 반면, NoSQL은 데이터를 읽어올 때 스키마에 따라 데이터를 읽어 온다. 이러한 방식을 **Schema on read**라고도 한다.

빅데이터, 메시징, 세션 관리 등 비정형 데이터에 적합하다.

**유형**

* key-value

속성을 key-value 쌍으로 나타내는 데이터를 배열의 형태로 저장ㅎ나다.

key는 속성 이름이고, value는 속성에 연결된 데이터 값을 의미한다.

대표적으로 Redis, Dynamo가 여기에 해당한다.

* document

데이터를 테이블이 아닌 문서처럼 저장하는 데이터베이스다.

JSON과 유사한 형식의 데이터를 문서화하여 저장한다.

각각의 문서는 하나의 속성에 대한 데이터를 가지고 있고, Colletion이라고 하는 그룹으로 묶어서 관리한다.

대표적으로 MonogoDB가 여기에 해당한다.

* wide-column store

데이터베이스의 열에 대한 데이터를 집중적으로 관리하는 데이터베이스이다.

각 열에는 key-value 형식으로 데이터가 저장되고 컬럼 패밀리라고 하는 열의 집합체 단위로 데이터를 처리할 수 있다.

하나의 행에 많은 열을 포함할 수 있어서 유연성이 높다.

주로 Cassandra, HBase가 여기에 해당한다.

* Graph

자료구조의 Graph와 비슷한 형식으로 데이터 간의 관계를 구성하는 데이터베이스다.

노드에 속성별로 데이터를 저장한다.

각 노드 간 관계는 간선으로 표현한다.

대표적으로 Neo4J, InfiniteGraph가 여기에 해당한다.

## 4. What is difference between RDB and NoSQL

1. 데이터 저장

NoSQL은 다양한 방식으로 저장한다.

RDB는 SQL를 이용해서 데이터를 저장한다.

2. 스키마

RDB에서 SQL를 사용하려면, 고정된 형식의 스키마가 필요하다. 즉, 처리하려는 데이터를 속성별로 컬럼에 대한 정보를 미리 정의해야 한다.

스키마는 변경 가능하지만, side-effect이 클 수 있다.

NoSQL은 동적으로 스키마의 형태를 관리할 수 있다. 데이터를 추가할 때 즉시, 새로운 컬럼을 추가할 수 있고, 개별 속성에 대해서 모든 컬럼에 대한 데이터를 반드시 입력하지 않아도 된다.

3. 쿼리

RDB는 테이블의 형식과 테이블 간의 관계에 맞춰 데이터를 요청해야 한다. 그래서 SQL를 사용한다.

NoSQL의 쿼리는 데이터 그룹 자체를 조회하는 것에 초점을 두고 있다. 그래서 SQL 없이 데이터 요청이 가능하다.

4. 확장성

RDB는 수직적으로 확장한다.

NoSQL은 수평적으로 확장한다.

### 각각의 사용 케이스

1. RDB

* DB의 ACID 성질을 준수해야 하는 경우

* 소프트웨어에 사용되는 데이터가 구조적이고 일관적인 경우

2. NoSQL

* 데이터의 구조가 거의 또는 전혀 없는 대용량의 데이터를 저장하는 경우

* 클라우드 컴퓨팅 및 저장공간을 최대한 활용하는 경우

* 빠르게 서비스를 구축하는 과정에서 데이터 구조를 자주 업데이트 하는 경우


[이 블로그가 정리를 너무 잘했다.](https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-sql-vs-nosql/)