## SSL이란

보안 소켓 계층의 약자로 브라우저와 서버 사이에 전송되는 데이터를 암호화하여 인터넷 연결을 보호하기 위한 표준 기술이다. 이 기술은 해커가 개인 데이터나 금융 데이터 등의 전송되는 정보를 보거나 훔치는 것을 방지한다.

### TLS : 전송 보안 계층

SSL의 향상된 버전이다.

### HTTPS

웹 사이트가 SSL/TLS 인증서로 보호되는 경우, HTTPS가 URL에 표시된다. 사용자는 브라우저 표시줄의 자물쇠 기호를 클릭해 발급 기관 및 웹 사이트 소유자의 상호를 포함한 인증서의 세부 정보를 불 수 있다. 

## SSL이 필요한 이유

- 결제 페이지
    
    고객이 결제를 위해 입력하는 신용카드 정보가 안전하다고 느낄 때, 구매를 할 가능성이 높아진다.
    
- 로그인 패널 및 양식
    
    사용자 이름과 비밀번호는 물론 개인 정보 제출에 사용되는 양식, 문서 또는 이미지를 암호화하고 보호한다.
    
- 블로그 및 정보 사이트
    
    결제 정보나 개인 정보와 같이 민감한 정보를 수집하지 않는 블로그나 웹사이트도 사용자 활동의 보호를 위해 필요하다.
    

## SSL 인증서

클라이언트와 서버 간의 통신을 제 3자가 보증 해주는 문서이다.

클라이언트가 서버에 접속한다.

서버는 클라이언트에게 인증서를 전달한다.

클라이언트는 인증서를 확인하고, 신뢰할 수 있는 서버인지 확인한다.

## SSL 장점

- 주고 받는 데이터를 제 3자에게 노출되는 것을 막을 수 있다.
- 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지 알 수 있다.
- 주고 받는 데이터가 악의적으로 변경되는 것을 막을 수 있다.

# 암호화 종류

## 대칭키

**동일한 키**로 암호화와 복호화를 할 수 있는 기법이다.

예를 들면, abc를 이용해 데이터를 암호화했다면, abc를 이용해야 복호화도 할 수 있다.

클라이언트와 서버가 데이터를 주고 받기 위해서는 서로가 반드시 대칭키를 알고 있어야 한다. 그렇기 때문에 통신에 앞서 대칭키를 전달하는 과정이 필요하다.

그런데 만약 중간에 대칭키가 유출된다면 대칭키를 얻은 제 3자는 암호화된 데이터를 복호화하여 볼 수 있기 때문에 HTTPS를 사용할 필요성이 사라진다. 

이러한 단점을 보완하기 위해 나온 방식이 공개키 방식이다.

## 공개키

대칭키 방식과 다르게 2개의 키를 가지고 시작한다.

- **공개키** → 타인에게 주는 거
- **비밀키(개인키)** → 나만 갖고 있는 거

공개키로 암호화하면 비밀키로 복호화한다.

비밀키로 암호화하면 공개키로 복호화한다.

예를 들어, 클라이언트가 서버의 공개키를 가지고 “data”를 암호화하여 서버에게 “he2oi”라는 데이터를 전달한다.

서버는 클라이언트가 보낸 “he2oi”라는 단어를 비밀키로 복호화하여 “data”라는 것을 확인한다.

공개키는 공개되어 있기에 보통 디지털 인증서 안에 포함되어 있다. 그래서 공개키가 존재한다는 것은 서버의 신원이 안전하다는 뜻이다. 이것을 전자서명이라 한다.

# SSL 통신 과정

![image](https://user-images.githubusercontent.com/61505572/185030167-167c2b89-05f7-49e3-8cb8-939448a6f322.png) <br/>
[사진 출처 - crocus](https://www.crocus.co.kr/1387)

1. **Client hello**

클라이언트는 **랜덤한 데이터**와 **현재 지원 가능한 암호화 방식들**을 서버에게 전달한다.

2. **Server hello**
- 인증서( 공개키를 포함 )
- 서버에서 생성한 랜덤한 데이터
- 가장 안전한 암호화 수단 방식

위의 3 가지를 클라이언트에게 전달한다.

3. **인증서 확인 pre master secret 암호화**

클라이언트는 내장되어 있는 CA 리스트에서 각 CA의 공개키를 이용하여 서버가 보낸 인증서를 복호화한다.

FAIL → 사용자에게 경고 메세지 보여주기.

SUCCESS → 해당 인증서는 CA의 개인키로 암호화 한 문서임이 보증되었기 때문에 서버를 신뢰할 수 있다. 

클라이언트가 전송한 랜덤 데이터와 서버가 전송한 랜덤 데이터를 조합해 pre master secret 키를 생성한다.

4. **pre master secret**

2번 단계에서  받은 공개키를 이용하여 pre master secret 키를 암호화하여 서버로 전송한다.

5. **서버는 pre master secret 값을 자신의 비밀키로 복호화한다.** 

이제 클라이언트와 서버 모두 pre master secret 키를 공유하게 된다.

6. **master secret & session key**

![image](https://user-images.githubusercontent.com/61505572/185030291-654e25bd-488f-4424-b667-70b65bc2c350.png) <br/>

[https://chp747.tistory.com/155](https://chp747.tistory.com/155)

클라이언트와 서버는 각자 *`pre master secret, 클라이언트의 랜덤 데이터, 서버의 랜덤 데이터`* 값을 **SHA-1, MD5 해쉬함수**를 이용해 master secret을 생성한다.

![image](https://user-images.githubusercontent.com/61505572/185030317-d6615c24-36ab-467d-a657-2279f180338d.png) <br/>
[https://chp747.tistory.com/155](https://chp747.tistory.com/155)

*`master secret, 클라이언트 랜덤 데이터, 서버 랜덤 데이터`* 값을 이용해 key material을 생성한다. key material을 4가지 키로 나눈다. 

- client write MAC secret : Client의 MAC을 생성하기 위한 키
- server write MAC secret : Server의 MAC을 생성하기 위한 키
- client write secret : Client의 데이터를 암호화/복호화하기 위한 키
- server write secret : Server의 데이터를 암호화/복호화하기 위한 키

위의 키들은 session key로 사용된다.

7. **session key를 통한 대칭키 암호화 통신**

session key를 이용해 클라이언트와 서버가 주고 받는 데이터를 제 3자로부터 보호한다.

> 대칭키는 양쪽 모두 알고 있는 값이며, 데이터를 암호화, 복호화 할 때 사용한다.
> 
8. **연결 종료**

데이터 전송이 끝나면, SSL 통신이 끝났음을 서로에게 알려주고 session key를 폐기한다.
