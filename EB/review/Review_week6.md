# Review of Studying week 6

## 빌드와 배포

컴파일은 컴퓨터가 이해할 수 있는 언어로 바꾸어주는 과정이다.

빌드는 소스코드를 실행가능한 파일로 만드는 과정이다. ( jar, war 파일로 만드는 과정 ) 

배포는 빌드로 만들어진 실행가능한 파일을 사용자가 접근할 수 있는 환경에 배치하는 것이다.

* 배포 프로세스

1. git에 소스 코드 올리기
2. 코드가 제대로 동작하는 지 테스트 코드 작성하기
3. 이를 수행 및 검증하기

위의 3가지 과정을 사용자가 직접 반복해서 해야한다. 이것을 자동화시키는 빌드/배포 자동화를 CI/CD라 한다.

### CI/CD

* CI 지속적 통합

1. 코드를 통합한다.
2. 통합한 코드가 제대로 동작하는지 테스트한다.
3. 제대로 빌드가 되는지 테스트한다.
4. 결과를 정리하고 버그가 존재한다면 기록한다.
5. 위의 과정을 반복한다.

모든 코들르 다 작성하고 통합하면 많은 에러가 발생한다 그래서 등장한 것이 주기적으로 통합하면서 발생하는 에러를 확인하고 수정하는 방식이다. 이것이 CI이다.

CI 도구로는 젠킨스와 트레비스가 있다.

* CD 지속적 배포

소프트웨어가 항상 테스트를 통과하고 빌드에 성공하는 신뢰 가능한 수준에서 지속적으로 배포될 수 있도록 관리하자는 개념이다. 따라서 CI가 선행되어야 한다.

1. Continuous Delivery

코드가 정상적으로 배포가 가능한 지 검증하고 검증이 완료되면 수동으로 배포

2. Continuous Deployment

코드가 정상적으로 배포가 가능한 지 검증하고 검증이 완료되면 자동으로 배포

[혜선님 자료 정리 참고](https://github.com/dldmsql/StudyForBE/blob/main/HS/BuildAndDeploy_HS.md)

### 무중단 배포

말그대로 어플리케이션의 중단 없이 배포하는 것을 말한다.

로드밸런서는 서버에 가해지는 부하를 분산해주는 장치 또는 기술을 통칭한다. 클라이언트와 서버 사이에 위치하며, 한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리해 각각의 서버가 최적의 성능을 낼 수 있돋록 한다.

[로드밸런서](https://m.post.naver.com/viewer/postView.naver?volumeNo=27046347&memberNo=2521903)

1. 롤링 배포

사용 중인 인스턴스 내에서 새 버전을 점진적으로 교체하는 것이다. 

서비스 중인 인스턴스 하나를 로드 밸런서에서 라우팅하지 않도록 한 뒤, 새 버전을 적용하여 다시 라우팅하도록 한다. 이를 반복하여 모든 인스턴스에 새 버전의 어플리케이션을 배포한다.

* 장점

인스턴스마다 차례로 배포를 하기에 상황에 따라 손쉽게 롤백할 수 있다. <br/>
추가적인 인스턴스를 늘리지 않아도 된다. <br/>
관리가 편하다. <br/>

* 단점

새 버전을 배포할 때, 인스턴스의 수가 감소하기 때문에 **사용 중인 인스턴스에 트래픽이 몰릴 수 있다.** 서비스 처리 용량을 고려해야 한다. <br/>
배포가 진행될 대, 구버전과 신버전이 공존하기에 **호환성 문제**가 발생할 수 있다. 사용자들이 균일한 서비스를 받지 못한다.

2. 블루-그린 배포

블루는 구버전, 그린은 신버전을 의미하며, 운영 중인 구버전과 동일하게 신버전의 인스턴스를 구성한 후 로드밸랜서를 통해 모든 트래픽을 한 번에 신버전 쪽으로 전환하는 방식이다.

* 장점

구버전의 인스턴스가 그대로 남아있어서 롤백이 쉽다. <br/>
구버전의 환경을 다음 배포에서 재사용할 수 있다. <br/>
운영환경에 영향을 주지 않고 새 버전을 테스트할 수 있다.

* 단점

시스템 자원이 2배로 필요하다.<br/>
새로운 환경에 대한 테스트가 전제되어야 한다.

3. 카나리 배포

잠재적 문제 상황을 미리 발견하기 위한 방식이다. 신버전을 소수의 유저들에겜나 배포를 해보고 문제가 없는 것을 확인해가며 점차 많은 유저들에게 배포하는 기법이다.

블루-그린과 유사하짐나 블루-그린처럼 트래픽을 한 번에 확 바꾸는 것이 아니라 단게적으로 전환하기에 부정적 영향을 최소화하고 상황에 따라 트래픽 양을 조절하며 롤백할 수 있다.

* 장점

문제 상황을 빠르게 감지할 수 있다. <br/>
A/B 테스트로 활용 가능하다.

* 단점

네트워크 트래픽 제어에 부담이 있다.

[무중단 배포 정리 with 움짤](https://llshl.tistory.com/47)

## 도커 정리

도커는 **어플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼**이다. 도커는 소프트웨어를 컨테이너라는 표준화된 유닛으로 패키징하며, 이 컨테이너에는 라이브러리, 시스템 도구, 코드, 런타임 등 소프트웨어를 실행하는 데 필요한 모든 것이 포함되어 있다. 

도커를 사용하면 환경에 구애받지 않고 어플리케이션을 신속하게 배포 및 확장할 수 았으며 코드가 문제업시 실행될 것을 보장받는다.

### 도커 작동 방식

도커는 **컨테이너를 위한 운영체제**이다. 가상 머신이 서버 하드웨어를 가상화하는 방식과 비슷하게 컨테이너는 서버 운영체제를 가상화한다. 도커는 각 서버에 설치되며 컨테이너를 구축, 시작 또는 중단하는데 사용할 수 있는 간단한 명령을 제공한다.

좀 더 구체적으로 살펴보자.

윈도우 기반 노트북에서 도커를 설치하여 사용한다고 하자. 물리 서버인 윈도우 서버 위에 도커가 동작하면서 리눅스 운영체제가 동작하게 된다. 리눅스 운영체제 위에서 도커 엔진이 동작하고 그 위에서 컨테이너가 동작한다. 컨테이너 내부에는 이미지가 존재하며 이들이 실행된다. 

컨테이너 안에는 **운영체제 비슷한 것**이 들어있다. 즉, 컨테이너 안에는 리눅스 운여에제 비슷한 무언가가 들어있다. 운영체제는 커널과 프로그램의 내용을 커널에 전달하고 커널이 하드웨어를 다루는 부분으로 구성된다. 

도커에서는 컨테이너가 완전히 분리되어 있으므로 밑바탕이 되는 리눅스 운영체제의 커널 외의 주변 부분이 컨테이너 속 프로그램의 명령을 전달 받을 수 없다. 따라서 컨테이너 속에 운영체제의 주변 부분이 들어 있어 프로그램의 명령을 전달받고 이를 커널에 전달하는 구조로 되어 있다. 

컨테이너 속에 리눅스 운영체제가 아닌 비슷한 것이 들어있다고 표현한 이유가 바로 리눅스 운영체제가 아닌 주변 부분만 들어 있기 때문이다.

### 도커는 기본적으로 리눅스용이다.

컨테이너에 들어가는 프로그램은 리눅스용이어야 한다. 도커가 기본적으로 리눅스 운영체제 위에서만 동작하기 때문이다. 즉, 도커는 리눅스 컴퓨터에 독립적인 환경을 만드는 것이며, 리눅스에섬나 동작하고 컨테이너에서 동작할 프로그램도 리눅스용 프로그램이어야 한다.

### 도커 사용 이유

도커를 사용하면, 코드를 더 빨리 배포할 수 있고, 어플리케이션 운영을 표준화할 수 있다. ( 환경이 동일하니까 ) 

### 도커 이미지, 컨테이너

이미지는 컨테이너를 만드는 틀 같은 것이고, 도커 허브는 인터넷 상에 도커 이미지를 모아놓은 곳이다.

이미지는 이미지 자체로는 큰 쓸모가 없다. 이미지는 컨테이너를 만드는 데 사용한다. 우리가 실제로 사용하는 것은 컨테이너이며, 이미지를 그대로 사용하는 일은 없다. 

컨테이너로도 이미지를 만들 수 있다. 이는 이미 만들어 둔 컨테이너로부터 이미지를 다시 만들고 이 이미지를 사용해 컨테이너를 만든다는 의미이다.

[이미지1] -> [컨테이너1] -컨테이너1을 이미지로!-> [이미지2] -> [컨테이너2]

컨테이너는 도커 엔진만 있으면 구동할 수 있다. 다른 서버나 컴퓨터에 도커 엔진이 설치되어 있다면 해당 도커 엔진에 이미지를 이용해 컨테이너를 생성해서 컨테이너 간에 이동을 할 수 있다. 

### 도커 컨테이너 생애주기

컨테이너는 오랫동안 아껴 쓰는 물건보다 그때 그때 쓰고 버리는 일회용품에 가깝다. 컨테이너는 쉽게 생성할 수 있으므로 하나를 가지고 계속 업데이트하기보다는 업데이트된 소프트웨어가 들어있는 새로운 컨테이너를 사용하는 것이 좋다.

컨테이너의 생이주기는 컨테이너를 만들고 실행하고 종료하고 폐기하고 다시 만드는 과정이다.

컨테이너를 파기한 후에 컨테이너에 들어있는 데이터는 당연하게 사라진다. 데이터를 보관하기 위해서는 물리적 컴퓨터의 일부를 마운트하고 데이터를 저장해야 한다. 보통 도커가 설치된 물리적 서버의 디스크를 마운트해서 이 디스크에 데이터를 저장한다. 

> 마운트는 디스크를 연결해 데이털르 기록할 수 있도록 한 상태로, 외장 USB 메모리와 하드디스크를 연결하는 것과 같다.

### 도커의 성질, 장단점

* 성질

1. 독립된 환경

여러 개의 컨테이너를 띄울 수 있다. <br/>
똑같은 어플리케이션 여러 개를 만들 수 있다. <br/>
일부만을 교체하거나 수정할 수 있다.

2. 이미지를 만들 수 있다.

이미지를 직접 만들고 배포할 수 있다.<br/>
이미지를 내려 받아 컨테이너로 사용할 수 있다. <br/>
이미지의 교체나 수정이 쉽다.

3. 컨테이너에 커널을 포함시킬 필요가 없다.

* 장점

1. 한 대의 물리 서버에 여러 대의 서버를 띄울 수 있다.

2. 서버 관리가 용이하다.

소프트웨어가 독립된 환경에 격리되어 있으므로 업데이트가 간단하다.<br/>
컨테이너 교체나 수정이 쉬워서 환경 이전이 쉽다.

3. 능숙한 개발자가 아니더라도 다루기 쉽다.

* 단점

1. 리눅스용 소프트웨어만 지원하낟.

2. 호스트 서버에 문제가 발생하면, 모든 컨테이너에 영향을 미친다.

3. 컨테이너 하나를 장기간에 걸쳐 사용할 경우, 큰 장점을 느끼기 어렵다.

### 도커, 언제 쓰면 좋을까

* 팀원 모두에게 동일한 개발 환경 제공

* 새로운 버전의 테스트

* 동일한 서버가 여러 대 필요한 경우

[도커의 모든 것 정리 - 시리즈로 구성](https://velog.io/@sorzzzzy/Docker-3.-%EB%8F%84%EC%BB%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98-%EC%83%9D%EC%95%A0%EC%A3%BC%EA%B8%B0%EC%99%80-%EC%9E%A5%EB%8B%A8%EC%A0%90)

## NoSQL, CAP 이론

### NoSQL

RDB를 제외한 나머지 유형의 저장소이다.

종류마다 쓰기/읽기 성능 특화, 2차 인덱스 지원, 자동 샤딩 지원과 같은 고유한 특징을 가진다. 대량의 데이터를 빠르게 처리하기 위해 메모리에 임시 저장하고 응답하는 등의 방법을 사용한다. 동저기 scale-out을 지원하기도 하며, 가용성을 위해 데이터 복제 등의 방법으로 RDB가 제공하지 못하는 성능과 기능을 제공한다.

### CAP 이론

분산 데이터베이스 시스템에서 의미 있는 이론이다. 분산 데이터베이스의 3가지 속성인 일관성, 가용성, 네트워크 파티션 허용을 나타낸다. 이론 발표 이후, 허점이 발견되었고 이를 보완하는 PACELC 이론이 등장했다.

* 분산 모델 기초

보통 분산 데이터베이스를 보면 기본적으로 복제와 샤딩을 지원한다. 복제 기능 덕에 특정 데이터베이스 노드에 장애가 발생해도 다른 노드에 복제된 데이터가 존재하기 때문에 안정적이다. 또한, READ DB와 WRITE DB로 역할을 나눠서 부하 분산 효과를 얻기도 한다. 그리고 샤딩을 통해 데이터를 각 노드에 나눠서 저장하면 부하 분산, 안정성 등의 효과를 얻을 수 있다.

일관성 + 가용성 : RDB

일관성 + 네트워크 파티션 허용 : MongoDB, Redis

가용성 + 네트워크 파티션 허용 : Dynamo

1. 일관성

다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증하는 것을 의미한다. 이것은 RDB가 지원하는 가장 기본적인 기능이지만, NoSQL을 사용한다면 데이터의 일관성이 느슨하게 처리되어 동일한 데이터가 나타나지 않을 수 있다. 
> 느슨하게 처리된다는 것은 데이터의 변경을 시간의 흐름에 다라 여러 노드에 전파하는 것을 말한다. 이러한 방법을 최종적으로 일관성이 유지된다고 하여 최종 일관성을 지원한다고 한다.

NoSQL에서는 분산 노드 간의 데이터 동기화를 위해 2가지 방법을 사용한다.

* 데이터의 저장 결과를 클라이언트로 응답하기 전에 모든 노드에 데이터를 저장하는 동기식 방법

->> 응답시간이 느리지만 데이터의 정합성을 보장한다.

* 메모리나 임시 파일에 기록하고 클라이언트에 먼저 응답한 다음, 특정 이벤트 또는 프로세스를 사용하여 노드로 데이터를 동기화하는 비동기식 방법

->> 빠른 응답시간을 보이지만, 쓰기 노드에 장애가 발생하였을 경우 데이터 손실 가능성

2. 가용성

모든 클라이언트의 읽기와 쓰기 요청에 대하여 항상 응답이 가능해야 함을 보장하는 것다. NoSQL은 클러스터 내에서 몇 개의 노드가 망가지더라도 정상적인 서비스가 가능하다.

몇몇 NoSQL은 가용성을 보장하기 위해 복제를 사용한다. 동일한 데이터를 다중 노드에 중복 저장하여 그 중 몇 대의 노드가 고장나도 데이터가 유실되지 않도록 하는 방법이다. 
    
    * Master-Slave
    
    동일한 데이터를 가진 저장소를 하나 더 생성하는 방법

    * Peer-to-Peer

    데이터 단위로 중복 저장하는 방법

3. 네트워크 분할 허용성

지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 네트워크가 단절되거나 네트워크 데이터의 유실이 일어나더라도 각 지역 내의 시스템은 정상적으로 동작해야 함을 의미한다.

### CAP 이론의 허점

1. CP

완벽한 일관성을 갖는 분산 시스템에서 데이터 변경은 존재하는 모든 노드에 복제되어야 완료된다. 이는 가용성과 성능에 큰 악영향을 끼친다. 만약 하나의 노드라도 문제가 있으면 트랜잭션은 실패한다. 그리고 노드가 늘어날 수록 지연시간은 길어진다.

2. AP

완벽한 가용성을 갖는 분산 시스템에서 모든 노드가 어떠한 상황에서도 응답할 수 있어야 한다. 네트워크 문제가 발생해서 어떤 노드에 복제가 제대로 이루어지지 않아도 가용성을 위해서 해당 노드에 접근한 사용자에게 데이터를 반환한다고 생각해보자. 이때 반환되는 데이터는 일관성이 깨진 데이터이며, 사용자는 이를 알 수 조차 없다.

3. CA

일관성과 가용성을 동시에 완벽히 만족하려면, 네트워크 장애를 허용하지 않아야 한다. 네트워크 장애가 절대 일어나지 않는 네트워크 구성이 가능할까? 불가능하다. 

### PACELC 이론

CAP 이론의 허점을 보완하기 등장했다. 네트워크 장애 상황과 정상 상황으로 나누어서 설명한다. 

P : 네트워크 파티션 상황 <br/>
A : 가용성 <br/> 
C : 일관성 <br/>
E : 정상 상황 <br/>
L : 지연 시간 <br/>

* PC/EC
* PC/EL
* PA/EC
* PA/EL

MySQL을 예로 들면, Master-Slave로 구성된 MySQL 서버는 기본적으로 PA/EL이다. 쓰기 작업을 끝내자 마자 읽으려고 하면 데이터가 없을 수 있다. 이는 정상 상황에서 일관성보다 지연 시간을 더 초점에 둔 케이스라고 보면 된다. MySQL은 따로 설정하지 않으면 Master에 트랜잭션 발생시 비동기적으로 Slave에 데이터를 복제한다. 그래서 복제될 때까지 딜레이를 주고 접근하게 코드를 수정하면 앞선 상황에서 정상적인 결과를 얻을 수 있다.

[DB에 관한 이론 정리](https://osy0907.tistory.com/m/95)

## SSL

Secure Socket Layer 프로토콜은 웹 서버와 웹 브라우저 사이의 보안을 강화하기 위해 등장했다. CA라 불리는 인증기관으로부터 서버와 클라이언트의 인증을 하는 데 사용된다. 

* 대칭키

암호를 만들 때 일종의 비밀번호이다.

* 공개키

1. 암호화 알고리즘으로 개인키를 생성한다.
2. 개인키로 비대칭 키인 공개키를 생성한다.
3. 상대방의 공개키로 평문을 암호화해서 전달한다.
4. 받은 이는 개인키로 파일을 복호화한다.

서버와 클라이언트 간의 통신을 위해서는 3 way handshake 과정을 거쳐야 한다. 이때 SSL 인증서를 주고 받는다.

공개키 방식은 암호화와 복호화할 때 사용하는 키가 서로 다르기 때문에 메세지를 전송하는 쪽이 공개키로 데이터를 암호화하고 수신 받는 쪽이 비공개키로 데이터를 복호화한다. 그러나 SSL에서는 이 방식을 사용하지 않는다. 공개키 방식의 암호화가 매우 많은 컴퓨터 자원을 사용하기 때문이다. 

그래서 SSL은 공개키와 대칭키의 장점을 혼합한 방식을 사용한다. 

1. 클라잉너트가 서버에게 연결 요청을 한다.

- 클라이언트가 지원하는 암호화 방식들
- 세션 아이디 ( 이미 연결 설정을 했다면 기존 새션을 재활용한다. )

2. 서버는 이에 대한 응답을 한다.

- 서버 측에서 생성한 랜덤 데이터
- 서버가 선택한 클라이언트의 암호화 방식
- 인증서

3. 클라이언트는 서버의 인증서가 CA에서 발급한 것인지 확인하기 위해 클라이언트에 내장된 CA 리스트를 확인한다. CA에 의해 발급된 인증서람녀 내장된 CA의 공개키를 이용해 인증서를 복호화한다. 클라이언트는 서버로부터 받은 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합해서 pre master secret이라는 키를 생성한다. 이 키는 세션에서 데이터를 주고 받을 때 암호화하기 위해 사용될 것이다. 이를 서버에 전달하는 방식이 공개키 방식이다. 

서버의 공개키로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 복호화한다. 서버의 공개키는 인증서에 있다. 

4. 서버는 클라이언트가 전송한 pre master secret 값을 자신의 비공개키로 복호화한다. 이제 서버와 클라이언트 모두 pre master secret 값을 공유하게 되었다. 이 값으로 master secret 값을 만들고 이를 통해 session key를 생성한다. session key는 비대칭 키로 서버와 클라이언트가 실제로 주고 받는 데이터를 암호화할 때 사용한다. 

[SSL 정리](https://lbm93.tistory.com/18)
