# What is System Call

## What is System Call

시스템 콜은 사용자 프로세스가 커널 프로세스에게 어떠한 **문맥을 요청**하면서 발생하는 것이다. 

### OS and System call

운영체제의 역할은 다음과 같다.

1. 사용자가 편하게 컴퓨터 시스템을 사용할 수 있는 환경을 제공한다.
2. 컴퓨터 시스템 안의 하드웨어를 효율적으로 관리한다.

현대의 운영체제는 대부분 시분할 시스템이다. 시분할은 일련의 작업들을 시간단위로 나눠서 처리하는 것이다. 이 작업들은 운영체제에서 자원을 할당받아서 돌아가는 프로세스이다.

이 시간 단위가 매우 짧기 때문에 사용자는 여러 프로그램들을 동시에 실행되는 것처럼 느낀다.

즉, 프로세스는 운영체제 위에서 실행 중인 프로그램이라고 볼 수 있다. 

자바는 C 언어와 달리 GC를 지원하면서 자원 반납에 대한 프로그래머의 부담이 없다. 

우리가 유튜브로 음악을 들으며 코딩을 한다고 생각해보자. 우리는 내부적으로 자원의 할당이나 반납을 고려하지 않고 사용한다. 이는 운영체제의 첫 번째 역할이 있기 때문이다.

C 언어로 프로그램을 작성할 때에는 개발자가 직접 메모리를 할당 받고 반납해야 했다. 이는 운영체제의 역할이다. 

운영체제는 크게 2가지 모드로 프로세스를 동작시킨다.

1. 사용자 모드
2. 커널 모드

사용자 모드는 우리가 사용하는 대부분의 프로그램들이 동작하는 모드이다.

커널 모드는 운영체제 내부의 커널이 관리하는 프로세스의 모드이다.

운영체제에서는 커널 모드를 통해 외부의 접근을 최소화해야 하는 영역을 지정해두고 보안성을 높인다. 즉, 사용자 모드가 커널 영역에 직접 접근하는 것이 아니라 운영체제에게 요청을 하면 해당 처리를 운영체제에 위임을 해서 처리하도록 한다. 이것이 바로 **시스템 콜**이다.

[네이버 블로그-그림 예제](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=sheep_horse&logNo=221271778167)

따라서 C 언어로 메모리 관리 함수를 실행하면 내부적으로 시스템 콜이 발생해서 운영체제에게 이 요청을 위임한다. 운영체제는 해당 명령어를 해석하고 할당해서 완료가 되면 해당 프로세스에게 알려주고 다시 프로세스는 사용자 모드로 동작한다.

단순하게 메모리 할당 뿐만 아니라 I/O 작업이나 네트워크 작업 등 커널 영역이 필요한 모든 곳에서는 시스템 콜이 필요하다.

### Java and System call

C 언어와 달리 자바는 JVM 위에서 동작하기에 시스템 콜 자체가 느려질 수 있다. 

* C 언어로 I/O 작업하기

[c 프로세스] -> [시스템 콜] -> [커널] -> [디스크 컨트롤러] -> [데이터 복사]

* java로 I/O 작업하기

[JVM] -> [JNI] -> [시스템 콜] -> [커널] -> [디스크 컨트롤러] -> [커널 버퍼 복사] -> [JVM 버퍼 복사]

위의 2개의 Flow를 보면, 자바는 시스템 콜을 사용하기 위해서 내부적으로 네이티브 메소드를 사용하기 때문에 느리다는 얘기가 나오게 되었다.

좀 더 구체적으로 자바의 읽기 과정을 살펴보자.

소스 코드에서 read 작업을 하면 시스템 콜이 발생한다. 이때 컨텍스트 스위칭이 이뤄진다. 커널에서 read 작업을 시작한다. 그 후, read 작업이 완료되면 커널 공간에서 유저 공간으로 데이터를 옮긴다. 디스크에서 프로세스 내부 버퍼로 복하는 과정에서 Blocking이 발생하기도 한다.

느린 점을 개선한 것이 nio 패키지이다.

### I/O 작업을 향상하기 위한 OS 기술

1. 버퍼
2. Scatter / Gather
3. 가상 메모리
4. 메모리 맵 파일
5. 파일 락

1. 버퍼

[사용자 모드]          [커널 모드]
    |                       |
[자바 프로세스]             |
    |                       |
    [버퍼]                  [버퍼]          [디스크 컨트롤러]          [디스크]

버퍼는 데이터를 하나씩 여러번 반복적으로 전달하는 것보다 중간에 위치해서 중간에서 데이터를 모으는 역할을 한다. 즉, 효율적으로 데이터를 전달하는 객체이다. 

2. Scatter / Gather

만약 내가 버퍼를 N개를 만들어서 사용한다고 하자. 동시에 I/O 작업이 이뤄지는 상황에서 N번의 시슽메 콜이 일어날 수 있다. 시스템 콜은 컨텍스트 스위칭과 비교해서 적은 비용이지만 그렇다고 아예 발생하지 않는 것은 아니다. 따라서 비효율적이다. 이러한 문제 때문에 등장한 것이 Scatter 와 Gather이다.

* Scattering READ

[사용자 모드]          [커널 모드]
    |                       |
[자바 프로세스]             |
    |                       |
    [버퍼]                  [버퍼]          [디스크 컨트롤러]          [디스크]
    [버퍼2]
    [버퍼3]

* Gathering Write

[사용자 모드]          [커널 모드]
    |                       |
[자바 프로세스]             |
    |                       |
    [버퍼]                  [버퍼]          [디스크 컨트롤러]          [디스크]
    [버퍼2]
    [버퍼3]

Scatter와 Gather의 흐름은 위와 같다. 이를 통하면 시스템 콜이 1번만 발생한다. 대신 내부적으로 호출할 때마다 사용할 버퍼의 주소 목록을 넘겨줌으로써 주어진 버퍼들로부터 순차적으로 읽거나 쓰기 작업을 한다.

자바에서는 이런 기능을 이용하기 위해 nio.channel 패키지에 ScatteringByteChannel과 GahteringByteChannel을 제공한다.

3. 가상 메모리

I/O 관점에서 가상 메모리를 사용하면 아래와 같은 이점이 존재한다.

* 실제 물리 메모리 크기보다 큰 가상 메모리 공간 사용 가능
* 여러 개의 가상 주소가 하나의 물리적 메모리 주소를 참조함으로써 메모리를 효율적으로 사용 가능

가상 메모리를 사용하면 2개의 버퍼를 사용하더라도 메모리 맵 파일을 통해서 동일한 영역에 접근이 가능해진다. 따라서 커널 영역에서 유저 영역으로 데이터를 복사하지 않아도 된다.

[사용자 모드]          [커널 모드]
    |                       |
[자바 프로세스]             |
    |                       |
    [버퍼]                  [버퍼]          [디스크 컨트롤러]          [디스크]
            \              /
              [가상 메모리]

위의 그림과 같이 사용자 모드와 커널 모드의 버퍼가 가상 메모리를 가리키며 사용한다.

4. 메모리 맵 파일

VScode로 공부한 내용을 정리하고 있다. 내가 타자를 칠 때마다 I/O 작업에 의한 시스템 콜이 발생할 것이다. 그리고 입력된 값을 다시 버퍼에 옮기는 작업이 이뤄질 것이고, 복사를 한 후에 가비지가 생기고 이를 또 가비지 컬렉터가 처리할 것이다.

가비지 컬렉터가 가비지를 수거하는 것은 상당히 느린 작업이고, 많은 사람들이 GC 튜닝하는 데 공을 들이는 이유일 것이다.

이러한 문제점을 해결하기 위해 운영체제가 지원하는 것이 MMIO이다. ( Memory-Mapped I/O )

MMIO를 통하면 읽기 작업과 쓰기 작업과 같은 시스템 콜을 사용할 필요가 없어진다. 또한, 메우 큰 파일을 복사하기 위해 많은 양의 메모리를 소비하지 않아도 된다. 내부적으로 MMIO는 시스템의 페이지들을 메모리로 바라보기 때문에 필요한 부분만 메모리에 로드해서 사용하기 때문이다.


5. 파일 락

어떠한 파일을 통해서 작업을 하고 있는데, 다른 프로세스나 쓰레드가 같은 파일에 대한 작업을 못하게 막아야 하는 경우, 락이 사용된다.

[자바와 시스템 콜 정리](https://brewagebear.github.io/java-syscall-and-io/)