# What is Network
## 목차
- IP
- TCP/UDP
- PORT
- DNS
- HTTP

## IP(Internet Protocol)
- 클라이언트와 서버에 IP 주소를 부여
    - 지정한 IP 주소에 데이터 전달
    - 패킷(Packet)이라는 통신 단위로 데이터 전달
        - 출발 IP, 도착 IP, 전송데이터로 구성
- 한계 
    - 통신을 하는 과정에서 많은 노드를 거치게 되는데, 클라이언트와 서버가 서로 연결이 안될 수도 있다. 이때 문제가 생긴다.
    - 비연결성: 패킷을 받을 대상이 없거나 서비스 불능 대상이어도 패킷을 전송한다.(대상 서버가 패킷을 받을 수 있는지 알 수 없다.)
    - 비신뢰성: 노드를 거치다가 해당 노드에 문제가 생겨서 중간에 패킷이 사라진다든가 패킷이 정해진 노드대로 오지 않고 중간에 경로가 바뀌어서 순서대로 오지 않을 수 있다.
    - 프로그램 구분: 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 2개 이상인 경우에도 문제가 생긴다.

## TCP/UDP
- IP의 한계를 해결해 주기 위해 TCP와 UDP가 나왔다.

### TCP(Transmission Control Protocol, 전송 제어 프로토콜)
- TCP/IP 패킷은 IP 패킷 정보에 출발지 PORT, 목적지 PORT, 전송 제거, 순서, 검증 정보 등이 담긴다.
- 신뢰할 수 있는 프로토콜이며 현재 대부분 TCP를 사용한다.

### 특징
- 연결지향(TCP 3 way handshake(가상 연결))
    1. 클라이언트에서 서버로 SYN(접속 요청) 메시지를 보낸다.
    2. 서버에서 클라이언트로 SYN+ACK 메시지를 보낸다.
    3. 클라이언트에서 서버로 ACK 메시지와 데이터를 보낸다.
    - 1,2 과정을 통해 서로 응답을 확인하고 나서 3번 과정을 통해 데이터를 보낸다.
    - 실제로 물리적으로 연결된 게 아니라 개념적으로 연결이 된 것(가상 연결)
- 데이터 전달 보증
    1. 클라이언트에서 서버로 데이터를 전송하면
    2. 서버에서 클라이언트로 데이터를 잘 받았다고 응답한다.
- 순서 보증
    1. 클라이언트에서 서버로 패킷1, 패킷2, 패킷3 순서로 전송했는데
    2. 서버에 패킷1, __패킷3__, 패킷2 순서로 도착했다면
    3. 서버에서 클라이언트로 패킷2부터 다시 보내라고 응답한다.

### UDP(User Datagram Protocol)
- 연결 지향(TCP 3 way handshake) 없음
- 데이터 전달 보증 안함
- 순서 보장 없음
- 단순하고 빠르다
- IP에 PORT, 체크섬 정도만 추가된 것
- 애플리케이션에서 추가 작업이 필요하다.

## PORT
- 같은 IP 내에서 프로세스를 구분하는 것
- 1:N으로 통신하려고 할 때 IP만으로는 구분하기 힘들기 때문에 PORT 사용
- 범위
    - 0 ~ 65535 까지 할당 가능
    - 0 ~ 1023은 기본적으로 사용하고 있기 때문에 건들지 않는 것이 좋음
    - 디폴트로 할당되는 포트 번호
        - FTP - 20, 21
        - TELNET - 23
        - HTTP - 80
        - HTTPS - 443

## DNS(Domain Name System)
- 일반적인 사용자의 입장에서 인터넷을 사용할 때 IP 주소를 외우기는 힘들기 때문에 'https://www.naver.com'과 같은 도메인 주소를 입력해서 인터넷을 사용한다. 
- IP 주소는 변경될 수 있다.
- DNS는 IP주소와 도메인 명을 매핑하는 일종의 전화번호부 역할을 한다.

## HTTP
- HyperText Transfer Protocol
- 인터넷을 사용하면서 다양한 홈페이지, 이미지, 영상, 음성 파일, JSON 등의 모든 것을 HTTP 메시지로 전송

### 특징
- 클라이언트-서버 구조
- 무상태 프로토콜(stateless), 비연결성
- HTTP 메시지
- 단순함, 확장 가능

1. 클라이언트 - 서버 구조
- 역할 분리: 클라이언트와 서버가 개념적으로 분리하게 되면서 서버는 __비즈니스 로직, 데이터__ 에 집중하게 되었고 클라이언트는 __UI, 사용성__ 에 집중하게 되었다.
    - 관심사를 분리함으로써 이슈가 발생해도 서로 영향을 받지 않고 각자 대응할 수 있게 되었다.

2. Stateful, Stateless
    - Stateful: 서버가 클라이언트의 상태를 보존한다.   
    - Stateless: 서버가 클라이언트의 상태를 보존하지 않는다.
    - Stateless 한계
        - 모든 것을 무상태로 설계할 수도 있고 안 할 수도 있다.
        - 상태 유지: 로그인하면 해당 상태를 서버에 유지해야 하는데, 일반적으로 브러우저 쿠키 & 서버 세션을 사용한다(상태 유지는 최소한으로 해야한다).
3. 비연결성(conectionless)
- HTTP는 기본적으로 연결이 유지되지 않는 모델
- 일반적으로 초 단위 이하의 빠른 속도로 응답
- 서버 자원을 매우 효율적으로 사용 가능

- 연결을 유지하는 모델
    - 여러 클라이언트에서 서버로 응답을 요청하면 서버는 요청이 들어온 클라이언트마다 연결을 유지해서 상태 저장
    - 사용자가 놀고 있어도 서버 자원은 계속 소모된다.
- 연결을 유지하지 않는 모델 
    - 서버는 클라이언트의 요청에 응답만 보내주고 연결을 끊는다.
    - 서버는 최소한의 자원으로 유지한다.
- 한계
    - 클라이언트가 요청할 때마다 TCP/IP 연결을 새로 맺어야 한다(3 way handshake 시간 추가)
    - 웹 브라우저로 사이트를 요청하면 HTML을 포함하여 자바스크립트, CSS, 이미지 등 많은 자원이 다운로드 된다.
- 지금은 HTTP 지속 연결로 문제 해결

## 참고
[인프런] 모든 개발자를 위한 HTTP 웹 기본 지식 - 김영한