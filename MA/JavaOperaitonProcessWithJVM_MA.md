# 자바 동작 과정

### 자바 동작 과정
1. 자바 소스코드(.java) 작성
2. (.java)인 소스 코드를 자바 컴파일러를 통해 자바 바이트 코드(.class)로 컴파일
3. 컴파일 된 바이트 코드를 JVM의 Class Loader에 전달 
4. Class Loader는 동적 로딩을 통해 필요 클래스들을 로딩 및 링크하여 Runtime Data Area(JVM의 메모리)에 올림 
5. 실행 엔진은 JVM메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행

#### 컴파일러 
>인간이 사용하는 고레벨언어(source code) 를 기계가 이해 할 수 있는 저레벨 언어(machine code)로 해석해주는 프로그램

#### 소스코드 (compling)-> 목적파일 (Linking)-> 실행파일
>소스파일 : 개발자가 작성하는 고레벨언어인 소스코드로 구성된 파일 ex .java ,*.c</br>
목적파일 : 소스파일을 컴파일해서 생긴 파일 ex) 바이트코드(가상머신이 이해할 수 있는 언어), 바이너리 코드(CPU가 이해할 수 있는 언어)

#### 바이트 파일 (.class) 
> 바이트 코드로 작성된 .class 파일은 기계가 읽기 편하도록 만들어 놓은 파일. </br>이 파일을 JVM이 읽어들여 실행. </br>클래스 파일을 실행하기 위해서는 필요한 모든.class 파일을 불러들이고, 코드를 검증한 뒤 메모리로 올리는 작업을 수행. </br>만약 클래스가 없거나 오류가 있다면 오류를 발생시키고, 그렇지 않으면 정상 수행.</br>
최종적으로 실행되는 실행파일x 

### Class Loader
- 클래스 로더는 여러 클래스 로더끼리 부모-자식 관계를 이루어 계층적인 구조
  - 부트스트랩 클래스 로더 (Bootstrap Class Loader)
    - 최상위 클래스로더, 유일하게 JAVA가 아닌 네이티브 코드로 구현
    - JVM이 실행될 때 같이 메모리에 올라감
    - Object 클래스를 비롯하여 JAVA API들을 로드함
  - 익스텐션 클래스 로더 (Extension Class Loader)
    - 기본 JAVA API를 제외한 확장 클래스들을 로드함 - 다양한 보안 확장 기능 로드
  - 시스템 클래스 로더 (System Class Loader)
    - (부트 스트랩과 익스텐션 클래스로더가 JVM 자체의 구성 요소들을 로드한다) 시스템 클래스 로더는 어플리케이션의 클래스들을 로드함
    - 사용자가 지정한 $CLASSPATH 내의 클래스들을 로드함
  - 사용자 정의 클래스 로더 (User-Defined Class Loader)
    - 어플리케이션 사용자가 직접 코드 상에서 생성하여 사용하는 클래스 로더
    - WAS와 같은 프레임워크는 서로 독립적으로 동작하게 하기 위해서 이를 위해 사용자 정의 클래스 로더들을 사용하여 클래스 로더의 위임 모델을 통해 어플리케이션의 독립성을 보장함

 - 클래스 로더 세부 동작
    1. 로드 : 클래스 파일을 가져와서 JVM의 메모리에 로드 
    2. 검증 : 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사
    3. 준비 : 클래스가 필요로 하는 메모리를 할당 (필드, 메서드, 인터페이스 등등) 
    4. 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
    > symbolic references? 참고하는 클래스의 특정 메모리 주소를 참조 관계로 구성한 것이 아닌 참조하는 대상의 이름으로 참조하는 것
    direct references? 참조하는 클래스의 특정 메모리 주소를 참조하는 것
    8. 초기화 : 클래스 변수들을 적절한 값으로 초기화 (tatic initializer들을 수행하고, static 필드들을 설정된 값으로 초기화) 

### JVM (Java Virtual Machine) 
> 자바 가상 머신. 프로그램을 실행 하기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현한 것으로 컴파일러로 변환된 .class 파일을 class loader를 통해 읽어 들여 자바 API와 함께 실행
- 운영체제의 구애 x, 메모리 관리 용이라는 자바의 장점 가능하게 해줌

#### JVM 실행과정
1. Class Loader를 통해 class 파일들을 JVM에 올림
2. JVM에 있는 .class 파일들을 Execution Engine 의 interpreter 와 JIT
complier를 통해 해석
3. 해석된 바이트 코드는 Runtime Data Areas에 배치되어 실질적인 수행 진행

> JVM의 Class Loader는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크 하여 Runtime Data Area에 올린다. 그후 Interpreter와 JIT compiler에 의해 동작되는 Execution Engine은 JVM에 올라온 바이트 코드(.class)들을 명령어 단위로 하나씩 가져와서 실행시

### 런타임 데이터 영역 (Runtime Data Area)
> JVM이 OS 위에서 실행되면서 할당받는 메모리 영역</br>
PC 레지스터, JVM 스택, 네이티브 메서드 스택은 스레드마다 하나씩 생성 힙, 메서드 영역은 모든 스레드가 공유해서 사용
- PC 레지스터 
  - Program Counter 레지스터는 현재 수행 중인 명령의 주소를 가지며 스레드가 시작될 때 생성되며, 각 스레드마다 하나씩 존재함
- JVM 스택 
  - 스택 프레임이라는 구조체를 저장하는 스택
  - 예외 발생 시 printStackTrace( ) 메서드로 보여주는 Stack Trace의 각 라인 하나가 스택 프레임을 표현함
  - 스레드가 시작될 때 생성되며 각 스레드마다 하나씩 존재함
- 네이티브 메서드 스택
  - 자바 외의 언어로 작성된 네이티브 코드를 위한 스택
  - JAVA Native Interface를 통해 호출하는 C/C++ 등의 코드를 수행하기 위한 스택으로, 언어에 맞게 스택 생성
- 힙
  - 인스턴스 또는 객체를 저장하는 공간
  - Garbage Collection의 대상
  - JVM 성능 등의 이슈에서 가장 많이 언급되는 공간
  - 힙 구성 방식이나 가비지 컬렉션 방법 등은 JVM 벤더들의 재량
- 메서드 영역 
  - 모든 스레드가 공유하는 영역
  - JVM이 시작될 때 생성
  - JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드에 대한 정보, static 변수, 메서드의 바이트 코드들을 보관함
- 런타임 상수 풀
  - JVM 동작에서 가장 핵심적인 역할을 수행하는 곳
  - 각 클래스와 인터페이스의 상수 뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블
  - 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조

### 실행 엔진 (Execution Engine)
> 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행

- 자바 소스코드 -[자바 컴파일러]-> 자바 바이트 코드 -[JIT complier]-> 네이티브 코드
#### 인터프리터 
- 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행
- 하나하나의 해석은 빠르지만 전체적인 실행 속도는 느림
- JVM 안에서 바이트 코드는 기본적으로 인터프리터 방식으로 동작
#### JIT complier
> JVM 의 Exectuion Engine 인터프리터를 개선하기 위해 도입된 것 

- 인터프리터는 각 행마다 읽어 변환하고, JIT complier는 바이트 코드를 전체를 읽어 한꺼번에 변환
- 코드 초기에 인터프리터에 의해 시작되고, 해당 코드를 충분히 많이 사용할 경우 JIT 컴파일러에서 컴파일을 수행
- 초기에 인터프리트 방식으로 바이트 코드를 변환하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 코드가 생성되는 것을 방지
- 이렇게 컴파일된 코드를 네이티브 코드 (캐시에 보관되기 때문에 한번 컴파일 된 코드는 빠르게 수행될 수 있음)
- JIT 컴파일러는 JVM의 핵심으로 JVM 내에서 성능에 가장 큰 영향

#### Garbage Collector
> 유효하지 않는 메모리, 즉 주소를 잃어버려서 사용할 수 없는 메모리를 Garbage를 해제 시켜 다른 용도로 사용할 수 있게 해주는 프로그램

- Garbage Collector를 수행할 땐 Garbage Collector를 수행하는 스레드를 제외한 모든 스레드들이 작업을 멈추고, 이후 완료되면 작업을 다시 시작

- C, C++는 사용자가 메모리를 직접 해제,자바는 Garbage Collector가 수행
- 메모리 누수(프로그램 구동 중에 필요치 않은 메모리가 계속해서 점유하고 있는 현상
)까지 잡아주지는 않음

## 참고자료
https://kingofbackend.tistory.com/123 </br>
https://github.com/gyoogle/tech-interview-for-developer/blob/master/Language/%5Bjava%5D%20%EC%9E%90%EB%B0%94%20%EC%BB%B4%ED%8C%8C%EC%9D%BC%20%EA%B3%BC%EC%A0%95.md  </br>
https://developer-youn.tistory.com/38 </br>
https://yaelimeee.tistory.com/70